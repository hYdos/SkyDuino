//#include <Arduino.h>
//#include <SPI.h>
//#include <MFRC522.h>
//
//#pragma clang diagnostic push
//#pragma clang diagnostic ignored "-Wunknown-attributes"
//#define RST_PIN 9 // Configurable, see typical pin layout above
//#define SS_PIN 10 // Configurable, see typical pin layout above
//
//MFRC522 mfrc522(SS_PIN, RST_PIN); // Create MFRC522 instance.
//
//MFRC522::MIFARE_Key flashedSkyKeyB;
//
//byte rawDump[64][16] = {
//        {0x0d, 0x3c, 0xd5, 0xdf, 0x3b, 0x81, 0x01, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x16, 0xc5, 0xfa},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x4b, 0x0b, 0x20, 0x10, 0x7c, 0xcb, 0x0f, 0x0f, 0x0f, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x26, 0x6b, 0xdc, 0x01, 0xe8, 0x61, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x06, 0x08, 0x52, 0x3f, 0xa2, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x93, 0x30, 0xe2, 0xfb, 0xd4, 0x43, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0xdf, 0xea, 0x4a, 0x5c, 0x7a, 0xc4, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x4c, 0xdc, 0xa0, 0xf5, 0x91, 0x25, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x6a, 0xb1, 0x74, 0xa6, 0x46, 0xe6, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0xf9, 0x87, 0x9e, 0x0f, 0xad, 0x07, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x61, 0x33, 0xcf, 0x40, 0xf0, 0x08, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0xf2, 0x05, 0x25, 0xe9, 0x1b, 0xe9, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0xd4, 0x68, 0xf1, 0xba, 0xcc, 0x2a, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x47, 0x5e, 0x1b, 0x13, 0x27, 0xcb, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x0b, 0x84, 0xb3, 0xb4, 0x89, 0x4c, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x98, 0xb2, 0x59, 0x1d, 0x62, 0xad, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0xbe, 0xdf, 0x8d, 0x4e, 0xb5, 0x6e, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
//        {0x2d, 0xe9, 0x67, 0xe7, 0x5e, 0x8f, 0x7f, 0x0f, 0x08, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
//};
//
//bool started = false;
//
///**
// * Helper routine to dump a byte array as hex values to Serial.
// */
//void dump_byte_array(byte *buffer, byte bufferSize) {
//    for (byte i = 0; i < bufferSize; i++) {
//        Serial.print(buffer[i] < 0x10 ? " 0" : " ");
//        Serial.print(buffer[i], HEX);
//    }
//}
//
//bool write_sector(byte sector, byte blockAddr, byte dataBlock[], MFRC522::MIFARE_Key flashedAKeys[]) {
//    MFRC522::StatusCode status;
//    byte globalBlockAddr = sector * 4 + blockAddr;
//
//    auto key = &flashedSkyKeyB;
//    auto keyType = MFRC522::PICC_CMD_MF_AUTH_KEY_B;
//    // if flashed these need to be keyB
//    if (sector == 0 || sector == 4) {
//        key = &flashedAKeys[sector + 1];
//        keyType = MFRC522::PICC_CMD_MF_AUTH_KEY_A;
//    }
//
//    bool authenticated = false;
//    Serial.println(F("Authenticating using key A..."));
//    // FIXME: assume blank
//    status = (MFRC522::StatusCode) mfrc522.PCD_Authenticate(keyType, globalBlockAddr, key, &(mfrc522.uid));
//    // for (byte keyIdx = 0; keyIdx < 17; keyIdx++) {
//    //     Serial.print(F("Using key (for A and B):"));
//    //     dump_byte_array(possibleKeys[keyIdx].keyByte, MFRC522::MF_KEY_SIZE);
//    //     status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, globalBlockAddr, &possibleKeys[0], &(mfrc522.uid));
//
//    if (status == MFRC522::STATUS_OK) {
//        Serial.println("Success with key!");
//        authenticated = true;
//        //break;
//    } else {
//        Serial.print(F(" PCD_Authenticate() failed: "));
//        Serial.println(MFRC522::GetStatusCodeName(status));
//        mfrc522.PCD_StopCrypto1();
//    }
//    // }
//
//    if (!authenticated) {
//        Serial.println("Failed to authenticate with key A :(");
//        return false;
//    }
//
//    // Write data to the block
//    Serial.println("Writing Data");
//    status = (MFRC522::StatusCode) mfrc522.MIFARE_Write(globalBlockAddr, dataBlock, 16);
//    if (status != MFRC522::STATUS_OK) {
//        Serial.print(F("MIFARE_Write() failed: "));
//        Serial.println(MFRC522::GetStatusCodeName(status));
//    }
//    Serial.println("Data Written");
//
//    // authenticated = false;
//    // Serial.println(F("Re-Authenticating using key A..."));
//    // for (byte keyIdx = 0; keyIdx < 17; keyIdx++) {
//    //     status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, globalBlockAddr, &possibleKeys[sector + 1], &(mfrc522.uid));
//
//    //     if (status == MFRC522::STATUS_OK) {
//    //         Serial.println("Success with key!");
//    //         authenticated = true;
//    //         break;
//    //     }
//    // }
//
//    // if(!authenticated) {
//    //     Serial.println("Failed to re-authenitcate with key A :(");
//    //     return false;
//    // }
//    Serial.println("Success hopefully :')");
//
//    // // Read data from the block (again, should now be what we have written)
//    // Serial.print(F("Verifying data from block "));
//    // Serial.print(globalBlockAddr);
//    // Serial.println(F(" ..."));
//    // status = (MFRC522::StatusCode)mfrc522.MIFARE_Read(globalBlockAddr, buffer, &size);
//    // if (status != MFRC522::STATUS_OK)
//    // {
//    //     Serial.print(F("MIFARE_Read() failed: "));
//    //     Serial.println(mfrc522.GetStatusCodeName(status));
//    // }
//
//    // // Check that data in block is what we have written
//    // // by counting the number of bytes that are equal
//    // Serial.println(F("Checking result..."));
//    // byte count = 0;
//    // for (byte i = 0; i < 16; i++)
//    // {
//    //     // Compare buffer (= what we've read) with dataBlock (= what we've written)
//    //     if (buffer[i] == dataBlock[i])
//    //         count++;
//    // }
//    // Serial.print(F("Number of bytes that match = "));
//    // Serial.println(count);
//    // if (count == 16)
//    // {
//    //     Serial.println(F("Success :-)"));
//    // }
//    // else
//    // {
//    //     Serial.println(F("Failure, no match :-("));
//    //     Serial.println(F("  perhaps the write operation didn't work properly..."));
//    //     return false;
//    // }
//    // Serial.println();
//    return true;
//}
//
///**
// * Initialize.
// */
//void setup() {
//    for (auto &i: flashedSkyKeyB.keyByte)i = 0x00; // Setup keyB
//    Serial.begin(9600);
//    while (!Serial);
//    SPIClass::begin();
//    mfrc522.PCD_Init();
//}
//
///**
// * Main loop.
// */
//void loop() {
//    auto currentMsg = Serial.readString();
//    if (currentMsg.startsWith("cmd")) {
//        auto cmd = currentMsg.substring(strlen("cmd"));
//        Serial.println("RESPONSE " + cmd);
//    }
//
////    if (started) return;
////
////    // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
////    if (!mfrc522.PICC_IsNewCardPresent())
////        return;
////
////    // Select one of the cards
////    if (!mfrc522.PICC_ReadCardSerial())
////        return;
////
////    // Show some details of the PICC (that is: the tag/card)
////    started = true;
////    Serial.print(F("Card UID:"));
////    dump_byte_array(mfrc522.uid.uidByte, mfrc522.uid.size);
////    Serial.println();
////    Serial.print(F("PICC type: "));
////    MFRC522::PICC_Type piccType = MFRC522::PICC_GetType(mfrc522.uid.sak);
////    Serial.println(MFRC522::PICC_GetTypeName(piccType));
////
////    // Check for compatibility
////    if (piccType != MFRC522::PICC_TYPE_MIFARE_1K) {
////        Serial.println(F("This sample only works with MIFARE Classic cards."));
////        return;
////    }
////
////    Serial.println("Generating key array");
////    MFRC522::MIFARE_Key possibleKeys[17];
////
////    // Write factory key
////    // using FFFFFFFFFFFFh which is the default at chip delivery from the factory
////    for (auto& i : possibleKeys[0].keyByte) {
////        i = 0xFF;
////    }
////
////    // Write key's on dump
////    for (byte sector = 0; sector < 16; sector++) {
////        for (byte i = 0; i < 6; i++) {
////            possibleKeys[1 + sector].keyByte[i] = rawDump[(sector * 4) + 3][i];
////        }
////    }
////
////    // // Write Skylander checksum, variant, and id
////    // Serial.println("Writing Skylander sector 0 data");
////    // write_sector(0, 1, rawDump[1], possibleKeys);
////
////    // Serial.println("Writing Skylander sector 3 data");
////    // write_sector(0, 3, rawDump[3], possibleKeys);
////
////    Serial.println("Replacing keys in other sectors");
////    // Replace keys with expected ones for UID
////    for (byte sector = 1 + 6; sector < 16; sector++) {
////        Serial.println(&"Writing sector " [ (int) sector]);
////
////        for (byte block = 0; block < 4; block++) {
////            Serial.println(&"Writing block " [ (int) block]);
////            write_sector(sector, block, rawDump[(sector * 4) + block], possibleKeys);
////        }
////    }
////
////
////    // Halt PICC
////    mfrc522.PICC_HaltA();
////    // Stop encryption on PCD
////    mfrc522.PCD_StopCrypto1();
//}
//
//#pragma clang diagnostic pop